// MockAPIOperator defines an structure which implements the APIOperator for providing 
// a mock usage in tests for use with the {{quote .Struct.Object.Name}} http API.
type MockAPIOperator struct{
    store *syncmap.Map
}

// NewMockAPIOperator returns a new instance of a MockAPIOperator.
func NewMockAPIOperator() *MockAPIOperator {
    return &MockAPIOperator{
        store: new(syncmap.Map),
    }
}

// Delete provides the operation to remove a giving record identified by ID.
func (m *MockAPIOperator) Delete(ctx context.Context, publicID string) error {
    if _, has := m.store.Load(publicID); !has {
        return fmt.Errorf("Record does not exists with id %q", publicID)
    }

    m.store.Delete(publicID)
    return nil
}

// GetAll returns a slice of all available record of type {{.Struct.Package}}.{{.Struct.Object.Name}}.
func (m *MockAPIOperator) GetAll(ctx context.Context, order string, orderBy string, page int, responserPerPage int) ([]{{.Struct.Package}}.{{.Struct.Object.Name}}, int, error) {
    var records []{{.Struct.Package}}.{{.Struct.Object.Name}}

    m.store.Range(func(k, v interface{}) bool {
        if elem, ok := v.({{.Struct.Package}}.{{.Struct.Object.Name}}); ok {
            records = append(records, elem)
        }

        return true
    })

    return records, len(records), nil
}

// Get retrieves a record based on the provided publicID.
func (m *MockAPIOperator) Get(ctx context.Context, publicID string) ({{.Struct.Package}}.{{.Struct.Object.Name}}, error){
    elem, found := m.store.Load(publicID)
    if !found{
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, fmt.Errorf("Record does not exists with id %q", publicID)
    }

    rElem, ok := elem.({{.Struct.Package}}.{{.Struct.Object.Name}})
    if !ok {
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, errors.New("Record does not match type")
    }

    return rElem, nil
}

// Update updates a giving record with the given new value.
func (m *MockAPIOperator) Update(ctx context.Context, publicID string, elem {{.UpdateAction.Package}}.{{.UpdateAction.Object}}) error{
{{ if .UpdateIsSimilar }}
    m.store.Store(publicID, elem)
    return nil
{{ else }}
    nowElem, ok := m.store.Load(publicID).({{.Struct.Package}}.{{.Struct.Object.Name}}) 
    if !ok {
        return errors.New("Not found/invalid type")
    }
    
    newElem, err := update{{.Struct.Object.Name}}(ctx, nowElem, elem)
    if err != nil {
        return err
    }

    m.store.Store(newElem.PublicID, newElem)

    return nil
{{ end }}
}

// Create adds a new record into the giving record store.
func (m *MockAPIOperator) Create(ctx context.Context, elem {{.CreateAction.Package}}.{{.CreateAction.Object}}) ({{.Struct.Package}}.{{.Struct.Object.Name}}, error){
{{ if .CreateIsSimilar }}
    m.store.Store(elem.PublicID, elem)
    return elem, nil
{{ else }}
    newElem, err := create{{.Struct.Object.Name}}(ctx, elem)
    if err != nil {
        return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, err
    }

    m.store.Store(newElem.PublicID, newElem)

    return newElem, nil
{{ end }}
}

{{ if (not .UpdateIsSimilar) }}
// update{{.Struct.Object.Name}} updates a exiting {{.Struct.Package}}.{{.Struct.Object.Name}} record with the given update item.
func Update{{.Struct.Object.Name}}(ctx context.Context, record {{.Struct.Package}}.{{.Struct.Object.Name}}, updater {{.UpdateAction.Package}}.{{.UpdateAction.Object}}) ({{.Struct.Package}}.{{.Struct.Object.Name}}, error){
    
    // TODO(developer):
    // Override function contents with what should happen.

    return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, errors.New("Not Implemented")
}
{{end}}

{{ if (not .CreateIsSimilar) }}
// create{{.Struct.Object.Name}} creates a new {{.Struct.Package}}.{{.Struct.Object.Name}} record from the given create type.
func create{{.Struct.Object.Name}}(ctx context.Context, elem {{.CreateAction.Package}}.{{.CreateAction.Object}}) ({{.Struct.Package}}.{{.Struct.Object.Name}}, error) {

    // TODO(developer):
    // Override function contents with what should happen.

    return {{.Struct.Package}}.{{.Struct.Object.Name}}{}, errors.New("Not Implemented")
}
{{end}}